"0","calc_zip_loglik <- function(par){"
"0","  lambda <- par[1]"
"0","  pi <- par[2]"
"0","  "
"0","  #this for loop is slightly inefficient but it allows us to see what is happening"
"0","  loglik <- 0"
"0","  "
"0","  for(j in x){"
"0","    "
"0","    indicator <- as.numeric(j > 0) #assign value 1 if greater than 0"
"0","    "
"0","    loglik <- loglik + log( (1 - indicator)*(pi + (1-pi)*exp(-lambda)) + indicator*((1-pi) * dpois(x = j , lambda = lambda))   )"
"0","  }"
"0","  "
"0","  return(loglik)"
"0","  "
"0","}"
"0","#If we maximise loglikelihood, we will be minimising AIC"
"0","mle_zip <-"
"0","  optim("
"0","  par = c(10,0.2), "
"0","  fn = calc_zip_loglik ,"
"0","  control = list(fnscale = -1), #maximise "
"0","  lower = c(0.1,0),"
"0","  upper = c(100,0.99999) ,"
"0","  method = ""L-BFGS-B"""
"0","  )"
"0","lambda_zip_estimate <- round(mle_zip$par[1],4)"
"0","pi_zip_estimate <- round(mle_zip$par[2],4)"
"0","aic_zip <- round(-2*mle_zip$value + 2*(2),2)"
"0","bic_zip <- round(-2*mle_zip$value + log(n),2)"
"0","data_frame(`$\\hat{\\lambda}$`= lambda_zip_estimate , `$\\hat{\\pi}$` = pi_zip_estimate,  AIC = aic_zip, BIC = bic_zip) %>% "
"0","  knitr::kable(caption = ""Zero inflated Poisson MLE's & information metrics"")"
"1","

"
"1","| $\hat{\lambda}$| $\hat{\pi}$|      AIC|      BIC|"
"1","
"
"1","|---------------:|-----------:|--------:|--------:|"
"1","
"
"1","|          9.2456|      0.2518| 15556.16| 15559.56|"
"1","
"
