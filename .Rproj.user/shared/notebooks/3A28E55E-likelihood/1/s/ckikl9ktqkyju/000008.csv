"0","calc_zip_loglik <- function(par){"
"0","  lambda <- par[1]"
"0","  pi <- par[2]"
"0","  "
"0","  #this for loop is slightly inefficient but it allows us to see what is happening"
"0","  loglik <- 0"
"0","  "
"0","  for(j in x){"
"0","    "
"0","    indicator <- as.numeric(j > 0) #assign value 1 if greater than 0"
"0","    "
"0","    loglik <- loglik + log( (1 - indicator)*(pi + (1-pi)*exp(-lambda)) + indicator*((1-pi) * dpois(x = j , lambda = lambda))   )"
"0","  }"
"0","  "
"0","  return(loglik)"
"0","  "
"0","}"
"0","#If we maximise loglikelihood, we will be minimising AIC"
"0","mle_zip <-"
"0","  optim("
"0","  par = c(10,0.2), "
"0","  fn = calc_zip_loglik ,"
"0","  control = list(fnscale = -1), #maximise "
"0","  lower = c(0.1,0),"
"0","  upper = c(100,0.99999) ,"
"0","  method = ""L-BFGS-B"""
"0","  )"
"0","lambda_zip_estimate <- mle_zip$par[1]"
"0","pi_zip_estimate <- mle_zip$par[2]"
"0","aic_zip <- -2*-mle_zip$value + 2*(2)"
"0","data_frame(`Lamda estimate`= lambda_zip_estimate , `Pi estimate` = pi_zip_estimate,  AIC = aic_zip) %>% knitr::kable()"
"1","

"
"1","| Lamda estimate| Pi estimate|       AIC|"
"1","
"
"1","|--------------:|-----------:|---------:|"
"1","
"
"1","|       9.245627|   0.2517669| -15548.16|"
"1","
"
