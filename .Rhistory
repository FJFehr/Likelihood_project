#first column is just an index, second is a  1632 observations
#first visualise the data
distribution_plot <- ggplot(dat, aes(Counts)) +
geom_bar(stat="count")+
labs(x="Accident counts", y="Frequency") +
scale_x_discrete(breaks = seq(0,65,by = 1),labels= paste(seq(0,65,by = 1))) +
labs(title="Histogram\n Accident counts") +
theme_classic()
# theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
distribution_plot <- ggplot(dat, aes(Counts)) +
geom_bar(stat="count")+
labs(x="Accident counts", y="Frequency") +
scale_x_discrete(breaks = seq(0,65,by = 1),labels= paste(seq(0,65,by = 1))) +
labs(title="Histogram\n Accident counts") +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
distribution_plot
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
scale_x_discrete(breaks = seq(0,65,by = 1),labels= paste(seq(0,65,by = 1))) +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
# scale_x_discrete(breaks = seq(0,65,by = 1),labels= paste(seq(0,65,by = 1))) +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
plot_grid(distribution_plot,firstbox,ncol = 1)
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
scale_x_discrete(breaks = seq(0,65,by = 1)) +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
scale_x_discrete() +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
?scale_x_discrete
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
scale_x_discrete(breaks=paste(seq(0,65,by=1))) +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
str(dat)
dat <- read.csv("data/accidents.csv") %>%
setNames(c("Index","Counts")) %>%
as_data_frame() %>%
mutate(Counts = as.numeric(Counts))
str(dat)
#first column is just an index, second is a  1632 observations
#first visualise the data
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
scale_x_discrete(breaks=paste(seq(0,65,by=1))) +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
scale_x_discrete(breaks=(seq(0,65,by=1))) +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
percentage_zero <- (dat$Counts==0)/nrow(dat)
percentage_zero
dat$Counts==0)
(dat$Counts==0)
percentage_zero <- sum(dat$Counts==0)/nrow(dat)
percentage_zero <- (sum(dat$Counts==0)/nrow(dat))*100 %>% round(digits = 2)
percentage_zero
(sum(dat$Counts==0)/nrow(dat))*100
percentage_zero <- (sum(dat$Counts==0)/nrow(dat))*100 %>% round(2)
percentage_zero
percentage_zero <- ((sum(dat$Counts==0)/nrow(dat))*100) %>% round(digits = 2)
percentage_zero
summary(dat$Counts) %>% knitr::kable()
summary(dat$Counts)
summarize(.data = dat$Counts, mean= mean(.)) %>% knitr::kable()
summarize(.data = dat$Counts, mean= mean(.))
summarize(.data = dat, mean= mean(Counts))
summarize(.data = dat, mean= mean(Counts), variance = var(Counts)) %>% knitr::kable()
summarize(.data = dat, Mean= mean(Counts), Variance = var(Counts), Median = median(Counts)) %>% knitr::kable()
```{r summary_stat , fig.cap = "Summary Statistics of accident data \\label{summary_stats}}
summarize(.data = dat, Mean= mean(Counts), Variance = var(Counts), Median = median(Counts)) %>% knitr::kable()
summarize(.data = dat, Mean= mean(Counts), Variance = var(Counts), Median = median(Counts)) %>% knitr::kable()
View(Dat)
#define usefule variables
x <- dat$Counts
n <- nrow(dat)
#we can use mle to fit this
mle_lambda <- sum(x)/n
mle_lambda
loglik_poisson <- -n*mle_lambda + sum(x)*log(mle_lambda) +log(prod(x))
prod(c(2,3))
loglik_poisson <- -n*mle_lambda + sum(x)*log(mle_lambda) +log(prod(x))
aic_poisson <- -2*loglik_poisson + 2(1)
aic_poisson <- -2*loglik_poisson + 2*(1)
summarize(`Lambda Estimate`= mle_lambda , AIC = aic_poisson) %>% knitr::kable()
data_frame(`Lambda Estimate`= mle_lambda , AIC = aic_poisson) %>% knitr::kable()
aic_poisson
loglik_poisson <- -n*mle_lambda + sum(x)*log(mle_lambda)  -log(prod(factorial(x)))
loglik_poisson
factorial(x)
sum(factorial(x))
loglik_poisson <- -n*mle_lambda + sum(x)*log(mle_lambda)  -sum(log(factorial(x)))
aic_poisson <- -2*loglik_poisson + 2*(1)
data_frame(`Lambda Estimate`= mle_lambda , AIC = aic_poisson) %>% knitr::kable()
#we can use mle to fit this
mle_lambda <- sum(x)/n
loglik_poisson <- -n*mle_lambda + sum(x)*log(mle_lambda)  -sum(log(factorial(x)))
aic_poisson <- -2*loglik_poisson + 2*(1)
data_frame(`Lambda Estimate`= mle_lambda , AIC = aic_poisson) %>% knitr::kable()
nrow(dat)
unlink('likelihood_cache', recursive = TRUE)
calc_negbinom_loglik <- function(params){
m <- params[1]
r <- params[2]
-n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
}
r <- 1
m <- 20
-n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
?optim
mle_negbinom <- optim(par = c(1,1), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = 0 )
calc_negbinom_loglik <- function(par){
m <- params[1]
r <- params[2]
-n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
}
mle_negbinom <- optim(par = c(1,1), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = 0 )
calc_negbinom_loglik <- function(params){
m <- params[1]
r <- params[2]
-n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
}
mle_negbinom <- optim(par = c(1,1), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = 0 , method ="Brent")
mle_negbinom <- optim(par = c(1,1), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = 0 , method ="L-BFGS-B")
mle_negbinom <- optim(par = c(1,1), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = c(0,0), upper =c(100,100) , method ="L-BFGS-B")
r <- 100
m <- 100
-n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
calc_negbinom_loglik <- function(params){
m <- params[1]
r <- params[2]
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <- optim(par = c(1,1), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = c(0,0), upper =c(100,100) , method ="L-BFGS-B")
mle_negbinom <- optim(par = c(2,2), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = c(0,0), upper =c(100,100) , method ="L-BFGS-B")
calc_negbinom_loglik <- function(m,r){
# m <- params[1]
# r <- params[2]
#
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <- optim(par = c(2,2), fn = calc_negbinom_loglik , control = list(fnscale = -1), lower = c(0,0), upper =c(100,100) , method ="L-BFGS-B")
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- par[2]
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = c(2, 2),
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = c(3, 3),
upper = c(100, 100) ,
method = "L-BFGS-B"
)
mle_negbinom
mle_negbinom <-
optim(
par = c(2, 2),
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = c(1, 1),
upper = c(100, 100) ,
method = "L-BFGS-B"
)
m_estimate <- mle_negbinom$par[1]
r_estimate <- mle_negbinom$par[2]
m_estimate
r_estimate
mle_negbinom$par
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- m^2 /(var(x)-m)
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = 1,
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = 1,
upper = 100 ,
method = "L-BFGS-B"
)
var(x)
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- m^2 /(var(x)-m)
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = 1,
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = 3,
upper = 30 ,
method = "L-BFGS-B"
)
mle_negbinom
m_estimate <- mle_negbinom$par[1]
r_estimate <- m_estimate^2 /(var(x)-m_estimate)
m_estimate
r_estimate
mle_negbinom$value
aic_negbinom <- -2*(-mle_negbinom$value) + 2*(1)
aic_negbinom
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- 1
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = 1,
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = 3,
upper = 30 ,
method = "L-BFGS-B"
)
m_estimate <- mle_negbinom$par[1]
m_estimate
r_estimate <- m_estimate^2 /(var(x)-m_estimate)
aic_negbinom <- -2*(-mle_negbinom$value) + 2*(2)
aic_negbinom
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- m^2 /(var(x)-m)
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) + sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = 1,
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = 3,
upper = 30 ,
method = "L-BFGS-B"
)
m_estimate <- mle_negbinom$par[1]
r_estimate <- m_estimate^2 /(var(x)-m_estimate)
aic_negbinom <- -2*-mle_negbinom$value + 2*(1)
aic_negbinom
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- m^2 /(var(x)-m)
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) - sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = 1,
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = 3,
upper = 30 ,
method = "L-BFGS-B"
)
m_estimate <- mle_negbinom$par[1]
r_estimate <- m_estimate^2 /(var(x)-m_estimate)
aic_negbinom <- -2*-mle_negbinom$value + 2*(1)
aic_negbinom
mle_negbinom$value
aic_negbinom <- -2*-mle_negbinom$value + 2*(1)
aic_negbinom
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 5, fig.pos="H", fig.pos = 'H')
# Note: Include = FALSE implies the code is executed, but not printed in your pdf.
# warning and message = FALSE implies ugly messages and warnings are removed from your pdf. These should be picked up when you execute the command chunks (code sections below) in your rmd, not printed in your paper!
library(knitr)
library(ggplot2)
library(kableExtra)
library(tidyverse)
library(cowplot)
#
# devtools::install_version("rmarkdown", version = "1.8", repos = "http://cran.us.r-project.org")
dat <- read.csv("data/accidents.csv") %>%
setNames(c("Index","Counts")) %>%
as_data_frame() %>%
mutate(Counts = as.numeric(Counts))
#define usefule variables
x <- dat$Counts
n <- nrow(dat)
#first column is just an index, second is a  1632 observations
#first visualise the data
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 5, fig.pos="H", fig.pos = 'H')
# Note: Include = FALSE implies the code is executed, but not printed in your pdf.
# warning and message = FALSE implies ugly messages and warnings are removed from your pdf. These should be picked up when you execute the command chunks (code sections below) in your rmd, not printed in your paper!
library(knitr)
library(ggplot2)
library(kableExtra)
library(tidyverse)
library(cowplot)
#
# devtools::install_version("rmarkdown", version = "1.8", repos = "http://cran.us.r-project.org")
dat <- read.csv("data/accidents.csv") %>%
setNames(c("Index","Counts")) %>%
as_data_frame() %>%
mutate(Counts = as.numeric(Counts))
#define usefule variables
x <- dat$Counts
n <- nrow(dat)
#first column is just an index, second is a  1632 observations
#first visualise the data
distribution_plot <- ggplot(dat, aes(Counts)) +
stat_count( fill="blue",
alpha = .4,
position="dodge")+
labs(x="Accident counts", y="Frequency" , title="Histogram\n Accident counts") +
theme_classic() +
theme(plot.title = element_text(hjust=0.5))
firstbox <- ggplot(dat)+
geom_boxplot(aes(y= dat$Counts,x=1),
fill = "cornflowerblue",
outlier.color ="firebrick")+
theme_classic() +
theme(plot.title = element_text(hjust=0.5))+
labs(title="Boxplot\n Accident counts") +
labs(y="Accident counts",x ="")+
coord_flip()
plot_grid(distribution_plot,firstbox,ncol = 1)
percentage_zero <- ((sum(dat$Counts==0)/nrow(dat))*100) %>% round(digits = 2)
summarize(.data = dat, Mean= mean(Counts), Variance = var(Counts), Median = median(Counts)) %>% knitr::kable()
#five number summary of the data
five_sum <- summary(dat)
#percentage outliers - 3rd quartile is 9
perc_outlier <- round(length(dat$Counts[dat$Counts > 1.5*9])/length(dat$Counts),4)*100
#we can use mle to fit this
mle_lambda <- sum(x)/n
loglik_poisson <- -n*mle_lambda + sum(x)*log(mle_lambda)  -sum(log(factorial(x)))
aic_poisson <- -2*loglik_poisson + 2*(1)
data_frame(`Lambda Estimate`= mle_lambda , AIC = aic_poisson) %>% knitr::kable()
#https://en.wikipedia.org/wiki/Negative_binomial_distribution#Gamma%E2%80%93Poisson_mixture
#use optim to optimise for r and m
#r is a shape parameter so it doesnt really affect the loglikelihood much
# we want mean = variance i think... therefore you can solve for r = m^2 /(sample variance  - m)
#This is done by looking at birgit's notes and seeing that variance = m + m^2/r
calc_negbinom_loglik <- function(par){
m <- par[1]
r <- m^2 /(var(x)-m)
loglik <- -n*log(gamma(r)) + sum(log(gamma(r+x))) - sum(log(factorial(x))) + sum(x) * log(m/(m+r)) + n*r*log(r/(r+m))
return(loglik)
}
#If we maximise loglikelihood, we will be minimising AIC
mle_negbinom <-
optim(
par = 1,
fn = calc_negbinom_loglik ,
control = list(fnscale = -1),
lower = 3,
upper = 30 ,
method = "L-BFGS-B"
)
m_estimate <- mle_negbinom$par[1]
r_estimate <- m_estimate^2 /(var(x)-m_estimate)
aic_negbinom <- -2*-mle_negbinom$value + 2*(1)
data_frame(`M Mean Estimate`= m_estimate , `r Shape Estimate` = r_estimate, AIC = aic_negbinom) %>% knitr::kable()
mean(x)
mean(x)^2 / (var(x)-mean(x))
